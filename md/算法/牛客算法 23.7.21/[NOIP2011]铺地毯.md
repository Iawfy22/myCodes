# [NOIP2011]铺地毯

链接：https://ac.nowcoder.com/acm/contest/20960/1016
来源：牛客网

## 题目描述                   

为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有n张地毯，编号从1到n。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。

## 输入描述

> 第一行，一个整数n，表示总共有n张地毯。
> 接下来的n行中，第i+1行表示编号i的地毯的信息，包含四个正整数a，b，g，k，每两个整数之间用一个空格隔开，分别表示铺设地毯的左下角的坐标（a，b）以及地毯在x轴和y轴方向的长度。
> 第n+2行包含两个正整数x和y，表示所求的地面的点的坐标（x，y）。

## 输出描述

> ```
> 输出共1行，一个整数，表示所求的地毯的编号；若此处没有被地毯覆盖则输出-1。
> ```



## 示例

输入

> ```
> 3
> 1 0 2 3
> 0 2 3 3
> 2 1 3 3
> 2 2
> ```

输出

> 3

说明

> 如下图，1号地毯用实线表示，2号地毯用虚线表示，3号用双实线表示，覆盖点（2，2）的最上面一张地毯是3号地毯。
>
> ![img](https://uploadfiles.nowcoder.com/images/20180612/305281_1528774377104_0F0630E6C662C42A3CD08E6125182E10)

## 备注

> 对于30%的数据，有n≤2；
> 对于50%的数据，有0≤a,b,g,k≤100；
> 对于100%的数据，有0≤n≤10,000，0≤a,b,g,k≤100,000





由题意得，该题需要简单模拟枚举

可以首先猜想**暴力枚举**——即，根据输入，每加一个地毯，就把地毯区域更改为对应编号，最后查找即可

但是考虑到时间复杂度——n * a * b ≈ 1e4  肯定会tle 所以要想办法优化枚举算法

> **优化枚举算法思路**——减少枚举次数

那怎么样才能减少枚举次数呢？

我们考虑到，最终查询的只是那一个点，所以我们尽可能只统计最终要查询的那个点的最上层地毯编号即可，没有覆盖到该点的地毯不用记录



**AC代码**

~~~C++
#include <bits/stdc++.h>

using namespace std;

const int N = 100010;

int n, x, y;
int a[N], b[N], g[N], k[N];  //四个参数
int id = -1;  // 编号

int main()
{
    scanf("%d", &n);
    for(int i = 1; i <= n; i ++)
        scanf("%d%d%d%d", a + i, b + i, g + i, k + i);
    scanf("%d%d", &x, &y);
    
    for(int i = 1; i <= n; i ++)
    {
        if(a[i] <= x && b[i] <= y && a[i] + g[i] >= x && b[i] + k[i] >= y)  //判断是否覆盖
            id = i;
    }
    
    cout<<id;
    
    return 0;
}
~~~

**时间复杂度O(n)**

总结以下就是——**那些和我们要求的没有关系的东西，能不维护就不维护**



其实对于本题，还有一种更快的方法（时间复杂度相同），就是最后从后往前遍历地毯数组，第一个出现的覆盖目标点的地毯编号即为答案

**AC代码**

~~~C++
#include <bits/stdc++.h>

using namespace std;

const int N = 100010;

int n, x, y;
int a[N], b[N], g[N], k[N];
int id = -1;

int main()
{
    scanf("%d", &n);
    for(int i = 1; i <= n; i ++)
        scanf("%d%d%d%d", a + i, b + i, g + i, k + i);
    scanf("%d%d", &x, &y);
    
    for(int i = n; i; i --)
        if(a[i] <= x && b[i] <= y && a[i] + g[i] >= x && b[i] + k[i] >= y){
            id = i;
            break;
        }
        
    cout<<id;
    
    return 0;
}
~~~

